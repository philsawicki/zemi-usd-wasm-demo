class TextureRegistry{constructor(e){this.basename=e,this.textures=[],this.loader=new THREE.TextureLoader}getTexture(e){if(this.textures[e])return this.textures[e];let t,s;this.textures[e]=new Promise(((e,i)=>{t=e,s=i}));let i,a=e;if("/"!==e[0]&&(a=this.basename+"["+e+"]"),e.indexOf(".png")>=e.length-5)i="image/png";else if(e.indexOf(".jpg")>=e.length-5)i="image/jpeg";else{if(!(e.indexOf(".jpeg")>=e.length-5))throw new Error("Unknown filetype");i="image/jpeg"}return window.driver.getFile(a,(e=>{if(!e)return void s(new Error("Unknown file: "+a));let r=new Blob([e.slice(0)],{type:i}),o=URL.createObjectURL(r);this.loader.load(o,(e=>{t(e)}),void 0,(e=>{s(e)}))})),this.textures[e]}}class HydraMesh{constructor(e,t){this._geometry=new THREE.BufferGeometry,this._id=e,this._interface=t,this._points=void 0,this._normals=void 0,this._colors=void 0,this._uvs=void 0,this._indices=void 0;const s=new THREE.MeshPhysicalMaterial({side:THREE.DoubleSide,color:new THREE.Color(65280)});this._mesh=new THREE.Mesh(this._geometry,s),this._mesh.castShadow=!0,this._mesh.receiveShadow=!0,window.usdRoot.add(this._mesh)}updateOrder(e,t,s=3){if(e&&this._indices){let i=[];for(let t=0;t<this._indices.length;t++){let a=this._indices[t];for(let t=0;t<s;++t)i.push(e[s*a+t])}this._geometry.setAttribute(t,new THREE.Float32BufferAttribute(i,s))}}updateIndices(e){this._indices=[];for(let t=0;t<e.length;t++)this._indices.push(e[t]);this.updateOrder(this._points,"position"),this.updateOrder(this._normals,"normal"),this._colors&&this.updateOrder(this._colors,"color"),this._uvs&&(this.updateOrder(this._uvs,"uv",2),this._geometry.attributes.uv2=this._geometry.attributes.uv)}setTransform(e){this._mesh.matrix.set(...e),this._mesh.matrix.transpose(),this._mesh.matrixAutoUpdate=!1}updateNormals(e){this._normals=e.slice(0),this.updateOrder(this._normals,"normal")}setMaterial(e){console.log("Material: "+e),this._interface.materials[e]&&(this._mesh.material=this._interface.materials[e]._material)}setDisplayColor(e,t){let s=!1;this._mesh.material===defaultMaterial&&(this._mesh.material=this._mesh.material.clone(),s=!0),this._colors=null,"constant"===t?this._mesh.material.color=(new THREE.Color).fromArray(e):"vertex"===t?(this._mesh.material.vertexColors=!0,s&&(this._mesh.material.color=new THREE.Color(16777215)),this._colors=e.slice(0),this.updateOrder(this._colors,"color")):console.warn(`Unsupported displayColor interpolation type '${t}'.`)}setUV(e,t,s){this._uvs=null,"facevarying"===s?this._geometry.setAttribute("uv",new THREE.Float32BufferAttribute(e,t)):"vertex"===s&&(this._uvs=e.slice(0),this.updateOrder(this._uvs,"uv",2)),this._geometry.attributes.uv2=this._geometry.attributes.uv}updatePrimvar(e,t,s,i){if("points"!==e&&"normals"!==e)switch(console.log("Setting PrimVar: "+e),e.startsWith("st")&&(e="uv"),e){case"displayColor":this.setDisplayColor(t,i);break;case"uv":this.setUV(t,s,i);break;default:console.warn("Unsupported primvar",e)}}updatePoints(e){this._points=e.slice(0),this.updateOrder(this._points,"position")}commit(){}}let defaultMaterial;class HydraMaterial{static usdPreviewToMeshPhysicalTextureMap={diffuseColor:"map",clearcoat:"clearcoatMap",clearcoatRoughness:"clearcoatRoughnessMap",emissiveColor:"emissiveMap",occlusion:"aoMap",roughness:"roughnessMap",metallic:"metalnessMap",normal:"normalMap",opacity:"alphaMap"};static channelMap={r:THREE.RGBFormat,rgb:THREE.RGBFormat,rgba:THREE.RGBAFormat};static usdPreviewToMeshPhysicalMap={clearcoat:"clearcoat",clearcoatRoughness:"clearcoatRoughness",diffuseColor:"color",emissiveColor:"emissive",ior:"ior",metallic:"metalness",opacity:"opacity",roughness:"roughness"};constructor(e,t){this._id=e,this._nodes={},this._interface=t,defaultMaterial||(defaultMaterial=new THREE.MeshPhysicalMaterial({side:THREE.DoubleSide,color:new THREE.Color(16722327),envMap:window.envMap})),this._material=defaultMaterial}updateNode(e,t,s){console.log("Updating Material Node: "+e+" "+t),this._nodes[t]=s}assignTexture(e,t){const s=HydraMaterial.usdPreviewToMeshPhysicalTextureMap[t];if(void 0!==s)if(e[t]&&e[t].nodeIn){const i=e[t].nodeIn.file,a=e[t].inputName,r=Object.keys(this._nodes).find((t=>this._nodes[t]===e));console.log(`Setting texture '${s}' (${i}) of material '${r}'...`),this._interface.registry.getTexture(i).then((t=>{if("alphaMap"===s)return i===e.diffuseColor?.nodeIn?.file&&"a"===a&&(this._material.map.format=THREE.RGBAFormat),this._material.transparent=!0,void(this._material.needsUpdate=!0);if("metalnessMap"===s)this._material.metalness=1;else if("emissiveMap"===s)this._material.emissive=new THREE.Color(16777215);else if(!HydraMaterial.channelMap[a])return void console.warn(`Unsupported texture channel '${a}'!`);const r=t.clone();r.format=HydraMaterial.channelMap[a],r.needsUpdate=!0,r.wrapS=THREE.RepeatWrapping,r.wrapT=THREE.RepeatWrapping,this._material[s]=r,this._material.needsUpdate=!0}))}else this._material[s]=void 0;else console.warn(`Unsupported material texture parameter '${t}'.`)}assignProperty(e,t){const s=HydraMaterial.usdPreviewToMeshPhysicalMap[t];void 0!==s?void 0===e[t]||e[t].nodeIn||(console.log(`Assigning property ${t}: ${e[t]}`),Array.isArray(e[t])?this._material[s]=(new THREE.Color).fromArray(e[t]):(this._material[s]=e[t],"opacity"===s&&e[t]<1&&(this._material.transparent=!0))):console.warn(`Unsupported material parameter '${t}'.`)}updateFinished(e,t){for(let e of t)e.nodeIn=this._nodes[e.inputId],e.nodeOut=this._nodes[e.outputId],e.nodeIn[e.inputName]=e,e.nodeOut[e.outputName]=e;let s;console.log("Finalizing Material: "+this._id);for(let e of Object.values(this._nodes))if(e.diffuseColor){s=e;break}if(s){console.log("Creating Material: "+this._id),this._material=new THREE.MeshPhysicalMaterial({});for(let e in HydraMaterial.usdPreviewToMeshPhysicalTextureMap)this.assignTexture(s,e);for(let e in HydraMaterial.usdPreviewToMeshPhysicalMap)this.assignProperty(s,e);window.envMap&&(this._material.envMap=window.envMap),console.log(this._material)}else this._material=defaultMaterial}}export class RenderDelegateInterface{constructor(e){this.registry=new TextureRegistry(e),this.materials={},this.meshes={}}createRPrim(e,t,s){console.log("Creating RPrim: "+e+" "+t);let i=new HydraMesh(t,this);return this.meshes[t]=i,i}createBPrim(e,t){console.log("Creating BPrim: "+e+" "+t)}createSPrim(e,t){if(console.log("Creating SPrim: "+e+" "+t),"material"===e){let e=new HydraMaterial(t,this);return this.materials[t]=e,e}}CommitResources(){for(const e in this.meshes)this.meshes[e].commit()}}